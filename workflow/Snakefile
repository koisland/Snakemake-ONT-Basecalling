import os
import re
import sys
import time


configfile: "config/config.yaml"


# {input_dir}/{run}/{subrun}/{flowcell}/pod5
RGX_DIR_PATTERN = re.compile(
    (
        f'{config["input_dir"]}/'
        + r"(?P<run_dir>"
        + config["run_dir_pattern"]
        + r")/(?P<subrun_dir>[^/]+)/(?P<flowcell>[^/]+)/pod5$"
    )
)
# Check if need to rebasecall on failed Snakemake run.
REBASECALL = config.get("rebasecall", False)


def get_run_dir_wcs(rgx_dir_pattern: str) -> tuple[list[str], list[str], list[str]]:
    # Walk through input directory check that regex pattern matches
    run_dirs, subrun_dirs, flowcell_dirs = [], [], []
    for root, _, _ in os.walk(config["input_dir"]):
        abs_path = os.path.join(config["input_dir"], root)
        mtch = re.search(rgx_dir_pattern, abs_path)
        if not mtch:
            continue

        run_dir, subrun_dir, flowcell_dir = mtch.groups()

        contains_summary_files = any(
            file.startswith("sequencing_summary")
            for file in os.listdir(
                os.path.join(config["input_dir"], run_dir, subrun_dir, flowcell_dir)
            )
        )
        # Skip directories that are still sequencing.
        if not contains_summary_files:
            continue

        run_dirs.append(run_dir)
        subrun_dirs.append(subrun_dir)
        flowcell_dirs.append(flowcell_dir)

    return run_dirs, subrun_dirs, flowcell_dirs


RUN_DIRS, SUBRUN_DIRS, FLOWCELL_DIRS = get_run_dir_wcs(rgx_dir_pattern=RGX_DIR_PATTERN)

# Split devices by number of cores provided.
DEVICES = round(4 / workflow.resource_settings.cores)


wildcard_constraints:
    run_dir="|".join(RUN_DIRS),
    subrun_dir="|".join(SUBRUN_DIRS),
    flowcell="|".join(FLOWCELL_DIRS),


# Check status of run by doing dry-run. If non-zero and error msg contaings IncompleteOutputException, update config wiht rebasecall.
# Then change params and output to include previous file.
rule dorado_basecaller:
    input:
        dorado_bin=config["dorado"]["bin"],
        pod5_directory=os.path.join(
            config["input_dir"], "{run_dir}", "{subrun_dir}", "{flowcell}", "pod5"
        ),
    output:
        os.path.join(
            config["input_dir"],
            "{run_dir}",
            "{subrun_dir}",
            "{flowcell}",
            "pod5",
            config["run_output_dir"],
            "{run_dir}.bam",
        ),
    resources:
        devices=DEVICES,
    params:
        rebasecall=REBASECALL,
        rebasecall_tmp_dir=os.path.join(
            "/tmp",
            "{run_dir}",
            "{subrun_dir}",
            "{flowcell}",
            "pod5",
            config["run_output_dir"],
        ),
        recursive="--recursive",
        model=config["dorado"]["model"],
        modifications=config["dorado"]["modifications"],
        min_qscore=config["dorado"]["min_qscore"],
    log:
        "logs/dorado_basecaller/{run_dir}_{subrun_dir}_{flowcell}.log",
    benchmark:
        "benchmarks/dorado_basecaller/{run_dir}_{subrun_dir}_{flowcell}.tsv"
    shell:
        """
        if [ "{params.rebasecall}" == "True" ]; then
            mkdir -p {params.rebasecall_tmp_dir}
            # Create empty file if it doesn't exist
            if ! [[ -f {output} ]]; then
                touch {output}
            fi
            tmp_file="{params.rebasecall_tmp_dir}/{wildcards.run_dir}.bam"
            {input.dorado_bin} basecaller \
                {params.model},{params.modifications} \
                {params.recursive} \
                {input.pod5_directory} \
                --min-qscore {params.min_qscore} \
                --device cuda:{resources.devices} \
                --resume-from {output} > $tmp_file 2> {log}
            mv $tmp_file {output}
        else
            {input.dorado_bin} basecaller \
                {params.model},{params.modifications} \
                {params.recursive} \
                --min-qscore {params.min_qscore} \
                --device cuda:{resources.devices} \
                {input.pod5_directory} > {output} 2> {log}
        fi
        """


rule all:
    input:
        expand(
            rules.dorado_basecaller.output,
            zip,
            run_dir=RUN_DIRS,
            subrun_dir=SUBRUN_DIRS,
            flowcell=FLOWCELL_DIRS,
        ),
    default_target: True
